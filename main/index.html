<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Hero with Synced Thumbnails</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      background: transparent;
      color: #fff;
    }

    .hero {
      width: 100%;
      height: 400px;
      max-height: 80vh;
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      background-color: transparent;
      transition: background-image 0.5s ease-in-out;
    }

    .thumbnail-container {
      overflow: hidden;
      width: 100%;
      max-width: calc(4 * (80px + 58px));
      margin: 10px 0 0;           /* desktop & tablet default gap */
      background: transparent;
      box-sizing: border-box;
      will-change: margin-left, margin-top;
    }

    .thumbnail-track {
      display: flex;
      align-items: flex-start;
      width: max-content;
      animation: scrollTrack 40s linear infinite;
      will-change: transform;
    }

    @keyframes scrollTrack {
      from { transform: translateX(0); }
      to   { transform: translateX(-50%); }
    }

    .thumbnail {
      margin: 0 29px;
      flex-shrink: 0;
      display: flex;
      align-items: flex-start;
      justify-content: center;
      cursor: pointer;
    }

    .thumbnail img {
      max-height: 100px;
      max-width: 80px;
      width: auto;
      height: auto;
      object-fit: contain;
      border-radius: 0;
      display: block;
      transition: transform 0.2s;
    }

    .thumbnail img:hover {
      transform: scale(1.05);
    }

    .hidden-track {
      visibility: hidden;
      height: 0;
      overflow: hidden;
    }

    /* --- RESPONSIVE FIXES --- */
    @media (max-width: 1024px) {
      .hero {
        height: 300px;
      }
      .thumbnail img {
        max-height: 80px;
        max-width: 65px;
      }
      .thumbnail {
        margin: 0 20px;
      }
      .thumbnail-container {
        max-width: calc(3 * (65px + 40px)); /* show ~3 thumbs on tablets */
        margin-top: 10px;                   /* keep tablet spacing same */
      }
    }

    @media (max-width: 600px) {
      .hero {
        height: 220px;
      }
      .thumbnail img {
        max-height: 60px;
        max-width: 50px;
      }
      .thumbnail {
        margin: 0 15px;
      }
      .thumbnail-container {
        max-width: calc(2.5 * (50px + 30px)); /* ~2â€“3 thumbs visible on mobile */
        /* margin-top is auto-adjusted by JS to pull closer to the hero image */
      }
    }
  </style>
</head>
<body>

  <div id="hero" class="hero"></div>

  <div class="thumbnail-container" id="thumbContainer">
    <div id="visibleTrack" class="thumbnail-track"></div>
  </div>

  <div class="hidden-track">
    <div id="hiddenTrack" class="thumbnail-track"></div>
  </div>

  <script>
    // All available images
    const allHeroImages = [
      "1.png", "2.png", "4.png", "5.png",
      "6.png", "7.png", "8.png", "9.png", "10.png", "11.png",
    ];

    const allDisplayThumbnails = [
      "1a.png", "2a.png", "4a.png", "5a.png",
      "6a.png", "7a.png", "8a.png", "9a.png", "10a.png", "11a.png",
    ];

    const heroImages = allHeroImages.slice(0, 11);
    const displayThumbnails = allDisplayThumbnails.slice(0, 11);

    const hero = document.getElementById('hero');
    const visibleTrack = document.getElementById('visibleTrack');
    const hiddenTrack = document.getElementById('hiddenTrack');
    const thumbContainer = document.getElementById('thumbContainer');

    // Duplicate for seamless scroll
    const fullHeroList = [...heroImages, ...heroImages];
    const fullDisplayList = [...displayThumbnails, ...displayThumbnails];

    // Build hidden track (logic)
    fullHeroList.forEach(src => {
      const thumb = document.createElement('div');
      thumb.className = 'thumbnail';
      const img = document.createElement('img');
      img.src = src;
      thumb.appendChild(img);
      hiddenTrack.appendChild(thumb);
    });

    // Build visible track (UI)
    fullDisplayList.forEach((src, idx) => {
      const thumb = document.createElement('div');
      thumb.className = 'thumbnail';
      const img = document.createElement('img');
      img.src = src;
      thumb.appendChild(img);

      // Click to jump hero, pause auto-scroll, resume after 5s
      img.addEventListener('click', () => {
        const baseIndex = idx % heroImages.length;
        currentIndex = baseIndex;
        hero.style.backgroundImage = `url(${heroImages[currentIndex]})`;
        alignThumbsToHeroImageLeft();

        visibleTrack.style.animationPlayState = "paused";
        clearTimeout(resumeTimeout);
        resumeTimeout = setTimeout(() => {
          visibleTrack.style.animationPlayState = "running";
        }, 5000);
      });

      visibleTrack.appendChild(thumb);
    });

    // Initial hero
    let currentIndex = 0;
    hero.style.backgroundImage = `url(${heroImages[currentIndex]})`;

    let resumeTimeout;

    // Helper: current effective thumbnail width (respects breakpoints)
    function getThumbWidth() {
      const thumbEl = document.querySelector('.thumbnail');
      const imgEl = document.querySelector('.thumbnail img');
      if (!thumbEl || !imgEl) return 138; // fallback to desktop value (80 + 58)

      const thumbStyle = getComputedStyle(thumbEl);
      const imgStyle = getComputedStyle(imgEl);

      const marginLeft = parseFloat(thumbStyle.marginLeft) || 0;
      const marginRight = parseFloat(thumbStyle.marginRight) || 0;
      const maxW = parseFloat(imgStyle.maxWidth) || 80;

      return maxW + marginLeft + marginRight;
    }

    // Align thumbnails under the visible *image* (not the full hero box)
    // and on mobile pull the rail closer to the hero image.
    function alignThumbsToHeroImageLeft() {
      const heroW = hero.clientWidth;
      const heroH = hero.clientHeight;
      const img = new Image();
      img.onload = () => {
        const naturalW = img.naturalWidth || 1;
        const naturalH = img.naturalHeight || 1;
        const scale = Math.min(heroW / naturalW, heroH / naturalH); // 'contain'
        const scaledW = naturalW * scale;
        const scaledH = naturalH * scale;

        // Horizontal letterbox padding -> move thumbnails to image's left edge
        const leftOffset = Math.max(0, (heroW - scaledW) / 2);
        thumbContainer.style.marginLeft = `${leftOffset}px`;

        // --- MOBILE-ONLY: tighten the vertical gap below the hero image ---
        if (window.innerWidth <= 600) {
          const verticalPad = Math.max(0, (heroH - scaledH) / 2); // top/bottom bars
          const desiredGap = 8; // px space we want between image & thumbnails
          // Pull the rail upward by the extra empty space (cap at -40px so it won't overlap too far)
          const mt = Math.max(-40, Math.round(desiredGap - verticalPad));
          thumbContainer.style.marginTop = `${mt}px`;
        } else {
          // Keep default spacing on tablet/desktop
          thumbContainer.style.marginTop = '10px';
        }
      };
      img.src = heroImages[currentIndex];
    }

    function updateHeroFromScroll() {
      if (visibleTrack.style.animationPlayState === "paused") {
        requestAnimationFrame(updateHeroFromScroll);
        return;
      }

      const trackRect = visibleTrack.getBoundingClientRect();
      const containerRect = thumbContainer.getBoundingClientRect();
      const offset = containerRect.left - trackRect.left;

      const widthPerThumb = getThumbWidth();
      const index = Math.floor(offset / widthPerThumb) % heroImages.length;

      if (index !== currentIndex) {
        currentIndex = index;
        hero.style.backgroundImage = `url(${heroImages[currentIndex]})`;
        alignThumbsToHeroImageLeft();
      }

      requestAnimationFrame(updateHeroFromScroll);
    }

    // Re-align on resize (debounced)
    let resizeTO;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTO);
      resizeTO = setTimeout(alignThumbsToHeroImageLeft, 100);
    });

    // Kick things off
    alignThumbsToHeroImageLeft();
    updateHeroFromScroll();
  </script>

</body>
</html>
